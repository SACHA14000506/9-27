{"f91416fe02259d5f100c47c3e5b0b23737c8b628":{"changes":{"test\/regress\/cli\/regress1\/arith\/issue3480.smt2":"MODIFY"},"diff":{"test\/regress\/cli\/regress1\/arith\/issue3480.smt2":[{"add":["1","; REQUIRES: no-asan"],"delete":[]}]}},"54ed57102bbd35241c68d128f88bf2b93dd236cf":{"changes":{"src\/main\/command_executor.cpp":"MODIFY"},"diff":{"src\/main\/command_executor.cpp":[{"add":["22","#include <memory>","24","#include <vector>","134","    std::vector<std::unique_ptr<Command> > getterCommands;","138","      getterCommands.emplace_back(new GetModelCommand());","142","      getterCommands.emplace_back(new GetProofCommand());","150","      getterCommands.emplace_back(new GetInstantiationsCommand());","155","      getterCommands.emplace_back(new GetSynthSolutionCommand());","160","      getterCommands.emplace_back(new GetUnsatCoreCommand());","163","    if (!getterCommands.empty()) {","168","      for (const auto& getterCommand : getterCommands) {","169","        status = doCommandSingleton(getterCommand.get());","170","        if (!status && !d_options.getContinuedExecution()) {","171","          break;","172","        }","173","      }"],"delete":["132","    Command* g = NULL;","136","      g = new GetModelCommand();","140","      g = new GetProofCommand();","148","      g = new GetInstantiationsCommand();","153","      g = new GetSynthSolutionCommand();","158","      g = new GetUnsatCoreCommand();","161","    if (g != NULL) {","166","      status = doCommandSingleton(g);","167","      delete g;"]}]}},"e5b43505cf6402bef3c156c36bf7e8a144a8d7c2":{"changes":{"test\/unit\/api\/c\/capi_solver_black.cpp":"MODIFY"},"diff":{"test\/unit\/api\/c\/capi_solver_black.cpp":[{"add":["3835","    cvc5_delete(s3);"],"delete":[]}]}},"81821f40c36a6ccbee4bf6ef500cd5dccacb634c":{"changes":{"src\/main\/command_executor.cpp":"MODIFY","src\/main\/command_executor.h":"MODIFY","src\/main\/driver_unified.cpp":"MODIFY"},"diff":{"src\/main\/command_executor.cpp":[{"add":["80","  if(seq != nullptr) {","122","    status = smtEngineInvoke(d_smtEngine, cmd, nullptr);","126","  const CheckSatCommand* cs = dynamic_cast<const CheckSatCommand*>(cmd);","127","  if(cs != nullptr) {","130","  const QueryCommand* q = dynamic_cast<const QueryCommand*>(cmd);","131","  if(q != nullptr) {","134"," const  CheckSynthCommand* csy = dynamic_cast<const CheckSynthCommand*>(cmd);","135","  if(csy != nullptr) {","139","  if((cs != nullptr || q != nullptr) && d_options.getStatsEveryQuery()) {"],"delete":["80","  if(seq != NULL) {","122","    status = smtEngineInvoke(d_smtEngine, cmd, NULL);","126","  CheckSatCommand* cs = dynamic_cast<CheckSatCommand*>(cmd);","127","  if(cs != NULL) {","130","  QueryCommand* q = dynamic_cast<QueryCommand*>(cmd);","131","  if(q != NULL) {","134","  CheckSynthCommand* csy = dynamic_cast<CheckSynthCommand*>(cmd);","135","  if(csy != NULL) {","139","  if((cs != NULL || q != NULL) && d_options.getStatsEveryQuery()) {"]}],"src\/main\/command_executor.h":[{"add":["61","  bool doCommand(std::unique_ptr<CVC4::Command>& cmd) {","62","    return doCommand(cmd.get());","63","  }","64",""],"delete":[]}],"src\/main\/driver_unified.cpp":[{"add":["62","    CVC4::main::CommandExecutor* pExecutor = nullptr;","65","    CVC4::TimerStat* pTotalTime = nullptr;","203","    std::unique_ptr<Command> cmd;","211","        cmd.reset(new SetOptionCommand(\"incremental\", SExpr(true)));","231","          cmd.reset(shell.readCommand());","236","        if (cmd == nullptr)","247","        cmd.reset(new SetOptionCommand(\"incremental\", SExpr(true)));","255","        \/\/ cmd.reset(new SetOptionCommand(\"incremental\", SExpr(false)));","284","          cmd.reset(parser->nextCommand());","285","          if (cmd == nullptr) break;","291","        if(dynamic_cast<PushCommand*>(cmd.get()) != nullptr) {","318","        } else if(dynamic_cast<PopCommand*>(cmd.get()) != nullptr) {","325","                std::unique_ptr<Command> ccmd(allCommands[i][j]->clone());","344","        } else if(dynamic_cast<CheckSatCommand*>(cmd.get()) != nullptr ||","345","                  dynamic_cast<QueryCommand*>(cmd.get()) != nullptr) {","374","        } else if(dynamic_cast<ResetCommand*>(cmd.get()) != nullptr) {","382","          if(dynamic_cast<GetUnsatCoreCommand*>(cmd.get()) == nullptr &&","383","             dynamic_cast<GetProofCommand*>(cmd.get()) == nullptr &&","384","             dynamic_cast<GetValueCommand*>(cmd.get()) == nullptr &&","385","             dynamic_cast<GetModelCommand*>(cmd.get()) == nullptr &&","386","             dynamic_cast<GetAssignmentCommand*>(cmd.get()) == nullptr &&","387","             dynamic_cast<GetInstantiationsCommand*>(cmd.get()) == nullptr &&","388","             dynamic_cast<GetAssertionsCommand*>(cmd.get()) == nullptr &&","389","             dynamic_cast<GetInfoCommand*>(cmd.get()) == nullptr &&","390","             dynamic_cast<GetOptionCommand*>(cmd.get()) == nullptr &&","391","             dynamic_cast<EchoCommand*>(cmd.get()) == nullptr) {","401","          if(dynamic_cast<QuitCommand*>(cmd.get()) != nullptr) {","408","        cmd.reset(new SetOptionCommand(\"incremental\", SExpr(false)));","433","          cmd.reset(parser->nextCommand());","434","          if (cmd == nullptr) break;","446","        if(dynamic_cast<QuitCommand*>(cmd.get()) != nullptr) {","476","    \/\/ Set the global executor pointer to nullptr first.  If we get a","496","  pTotalTime = nullptr;","497","  pExecutor = nullptr;"],"delete":["62","    CVC4::main::CommandExecutor* pExecutor = NULL;","65","    CVC4::TimerStat* pTotalTime = NULL;","203","    Command* cmd;","211","        cmd = new SetOptionCommand(\"incremental\", SExpr(true));","214","        delete cmd;","232","          cmd = shell.readCommand();","237","        if (cmd == NULL)","241","          delete cmd;","244","        delete cmd;","250","        cmd = new SetOptionCommand(\"incremental\", SExpr(true));","253","        delete cmd;","259","        \/\/ cmd = new SetOptionCommand(\"incremental\", SExpr(false));","262","        \/\/ delete cmd;","289","          cmd = parser->nextCommand();","290","          if (cmd == NULL) break;","296","        if(dynamic_cast<PushCommand*>(cmd) != NULL) {","323","        } else if(dynamic_cast<PopCommand*>(cmd) != NULL) {","330","                Command* ccmd = allCommands[i][j]->clone();","337","                delete ccmd;","350","        } else if(dynamic_cast<CheckSatCommand*>(cmd) != NULL ||","351","                  dynamic_cast<QueryCommand*>(cmd) != NULL) {","380","        } else if(dynamic_cast<ResetCommand*>(cmd) != NULL) {","388","          if(dynamic_cast<GetUnsatCoreCommand*>(cmd) == NULL &&","389","             dynamic_cast<GetProofCommand*>(cmd) == NULL &&","390","             dynamic_cast<GetValueCommand*>(cmd) == NULL &&","391","             dynamic_cast<GetModelCommand*>(cmd) == NULL &&","392","             dynamic_cast<GetAssignmentCommand*>(cmd) == NULL &&","393","             dynamic_cast<GetInstantiationsCommand*>(cmd) == NULL &&","394","             dynamic_cast<GetAssertionsCommand*>(cmd) == NULL &&","395","             dynamic_cast<GetInfoCommand*>(cmd) == NULL &&","396","             dynamic_cast<GetOptionCommand*>(cmd) == NULL &&","397","             dynamic_cast<EchoCommand*>(cmd) == NULL) {","407","          if(dynamic_cast<QuitCommand*>(cmd) != NULL) {","408","            delete cmd;","412","        delete cmd;","416","        cmd = new SetOptionCommand(\"incremental\", SExpr(false));","419","        delete cmd;","442","          cmd = parser->nextCommand();","443","          if (cmd == NULL) break;","455","        if(dynamic_cast<QuitCommand*>(cmd) != NULL) {","456","          delete cmd;","459","        delete cmd;","487","    \/\/ Set the global executor pointer to NULL first.  If we get a","507","  pTotalTime = NULL;","508","  pExecutor = NULL;"]}]}},"9cd5bbf8c659d2e260bad71a841f5153f358a58b":{"changes":{"\/dev\/null":"DELETE","test\/regress\/regress3\/siegel-nl-bases.smt2":"ADD","test\/regress\/CMakeLists.txt":"MODIFY"},"diff":{"\/dev\/null":[{"add":[],"delete":[]}],"test\/regress\/regress3\/siegel-nl-bases.smt2":[{"add":[],"delete":[]}],"test\/regress\/CMakeLists.txt":[{"add":["2098","  regress3\/siegel-nl-bases.smt2"],"delete":["2023","  regress2\/nl\/siegel-nl-bases.smt2"]}]}},"7ee7051df025e6db566fc67086a7aa4e1023c8f2":{"changes":{"test\/api\/c\/issue11069.c":"MODIFY"},"diff":{"test\/api\/c\/issue11069.c":[{"add":["2"," *   Andrew Reynolds, Daniel Larraz","62","","63","  cvc5_parser_delete(parser);","64","  cvc5_symbol_manager_delete(sm);","65","  cvc5_delete(slv);","66","  cvc5_term_manager_delete(tm);","67",""],"delete":["2"," *   Andrew Reynolds"]}]}},"f18f1bd8c6bcc6827893a2c25e67ca8cf0ddca20":{"changes":{"src\/expr\/type_node.cpp":"MODIFY","test\/api\/cpp\/CMakeLists.txt":"MODIFY","test\/api\/cpp\/proj-issue399.cpp":"ADD"},"diff":{"src\/expr\/type_node.cpp":[{"add":["59","      nb << (*j).substitute(type, replacement);"],"delete":["59","      (*j).substitute(type, replacement);"]}],"test\/api\/cpp\/CMakeLists.txt":[{"add":["58","cvc5_add_api_test(proj-issue399)"],"delete":[]}],"test\/api\/cpp\/proj-issue399.cpp":[{"add":[],"delete":[]}]}},"60173f62a82b4d71f2fbac51880d44d883ae5109":{"changes":{"src\/theory\/theory.cpp":"MODIFY","test\/regress\/regress0\/arrays\/bug3020.smt2":"ADD","test\/regress\/CMakeLists.txt":"MODIFY"},"diff":{"src\/theory\/theory.cpp":[{"add":["297","        && (in[1].getType()).isSubtypeOf(in[0].getType())","298","        && in[0].getKind() != kind::BOOLEAN_TERM_VARIABLE)","304","        && (in[0].getType()).isSubtypeOf(in[1].getType())","305","        && in[1].getKind() != kind::BOOLEAN_TERM_VARIABLE)"],"delete":["297","        && (in[1].getType()).isSubtypeOf(in[0].getType()))","303","        && (in[0].getType()).isSubtypeOf(in[1].getType()))"]}],"test\/regress\/regress0\/arrays\/bug3020.smt2":[{"add":[],"delete":[]}],"test\/regress\/CMakeLists.txt":[{"add":["37","  regress0\/arrays\/bug3020.smt2"],"delete":[]}]}},"5d6664a43c8ea3400b0f38797c937568d8d0ca2a":{"changes":{"test\/unit\/parser\/parser_black.h":"MODIFY"},"diff":{"test\/unit\/parser\/parser_black.h":[{"add":["143","        std::unique_ptr<Command> cmd(","144","            static_cast<Smt2*>(parser)->setLogic(\"QF_LIA\"));"],"delete":["143","        static_cast<Smt2*>(parser)->setLogic(\"QF_LIA\");"]}]}},"024777bc78b45ad5852715403af035b0dc615e62":{"changes":{"test\/regress\/cli\/regress2\/bug674.smt2":"MODIFY"},"diff":{"test\/regress\/cli\/regress2\/bug674.smt2":[{"add":["0","; COMMAND-LINE: --quant-ind --incremental --ieval=off"],"delete":["0","; COMMAND-LINE: --quant-ind --incremental"]}]}},"b994f336a7db6180427014721d673519ee6febf3":{"changes":{"test\/regress\/regress0\/quantifiers\/issue8001-mem-leak.smt2":"ADD","src\/theory\/quantifiers\/quant_conflict_find.h":"MODIFY","src\/theory\/quantifiers\/quant_conflict_find.cpp":"MODIFY","test\/regress\/CMakeLists.txt":"MODIFY"},"diff":{"test\/regress\/regress0\/quantifiers\/issue8001-mem-leak.smt2":[{"add":[],"delete":[]}],"src\/theory\/quantifiers\/quant_conflict_find.h":[{"add":["126","  using VarMgMap = std::map<size_t, std::unique_ptr<MatchGen>>;"],"delete":["126","  typedef std::map<size_t, MatchGen*> VarMgMap;"]}],"src\/theory\/quantifiers\/quant_conflict_find.cpp":[{"add":["72","        d_var_mg[j] = nullptr;","79","          d_var_mg[j] = std::make_unique<MatchGen>(p, this, d_vars[j], true);","282","  for (const std::pair<const size_t, std::unique_ptr<MatchGen>>& vg : d_var_mg)"],"delete":["72","        d_var_mg[j] = NULL;","79","          d_var_mg[j] = new MatchGen(p, this, d_vars[j], true);","282","  for (const std::pair<const size_t, MatchGen*>& vg : d_var_mg)"]}],"test\/regress\/CMakeLists.txt":[{"add":["984","  regress0\/quantifiers\/issue8001-mem-leak.smt2"],"delete":[]}]}},"1307691a6306e84efb4e194755bb111fa0843dd4":{"changes":{"src\/expr\/symbol_table.cpp":"MODIFY"},"diff":{"src\/expr\/symbol_table.cpp":[{"add":["51","  ~Implementation() {","52","    d_exprMap->deleteSelf();","53","    d_typeMap->deleteSelf();","54","    d_functions->deleteSelf();","55","  }","56",""],"delete":[]}]}},"c699290e5e5e037fc3b68f6b683f8b6f6ca5f106":{"changes":{"test\/unit\/api\/c\/capi_term_manager_black.cpp":"MODIFY","test\/unit\/api\/c\/capi_symbol_manager_black.cpp":"MODIFY"},"diff":{"test\/unit\/api\/c\/capi_term_manager_black.cpp":[{"add":["1569","  Cvc5* solver = cvc5_new(d_tm);","1570","  Cvc5Sort s2 = cvc5_mk_array_sort(d_tm, d_int, d_int);","1571","  Cvc5Term t1 = cvc5_mk_const(d_tm, d_int, \"i\");","1572","  Cvc5Term t2 = cvc5_mk_const(d_tm, s2, \"a\");","1573","  std::vector<Cvc5Term> args = {t2, t1};","1574","  args = {cvc5_mk_term(d_tm, CVC5_KIND_SELECT, args.size(), args.data()), t1};","1575","  cvc5_assert_formula(","1576","      solver, cvc5_mk_term(d_tm, CVC5_KIND_EQUAL, args.size(), args.data()));","1577","  cvc5_check_sat(solver);","1578","","1605","  cvc5_delete(solver);"],"delete":["1569","  {","1570","    Cvc5* solver = cvc5_new(d_tm);","1571","    Cvc5Sort s2 = cvc5_mk_array_sort(d_tm, d_int, d_int);","1572","    Cvc5Term t1 = cvc5_mk_const(d_tm, d_int, \"i\");","1573","    Cvc5Term t2 = cvc5_mk_const(d_tm, s2, \"a\");","1574","    std::vector<Cvc5Term> args = {t2, t1};","1575","    args = {cvc5_mk_term(d_tm, CVC5_KIND_SELECT, args.size(), args.data()), t1};","1576","    cvc5_assert_formula(","1577","        solver, cvc5_mk_term(d_tm, CVC5_KIND_EQUAL, args.size(), args.data()));","1578","    cvc5_check_sat(solver);","1579","  }"]}],"test\/unit\/api\/c\/capi_symbol_manager_black.cpp":[{"add":["53","    cvc5_parser_delete(parser);"],"delete":[]}]}},"94b6eb7290ef4f785dc8ad50c35547f63724e502":{"changes":{"\/dev\/null":"DELETE","test\/regress\/cli\/regress3\/issue4707-bv-to-bool-large.smt2":"ADD","test\/regress\/cli\/CMakeLists.txt":"MODIFY"},"diff":{"\/dev\/null":[{"add":[],"delete":[]}],"test\/regress\/cli\/regress3\/issue4707-bv-to-bool-large.smt2":[{"add":[],"delete":[]}],"test\/regress\/cli\/CMakeLists.txt":[{"add":["3675","  regress3\/issue4707-bv-to-bool-large.smt2"],"delete":["3558","  regress2\/issue4707-bv-to-bool-large.smt2"]}]}},"8e54d07417914793378b4ccffd3bfe249ae6d54b":{"changes":{"src\/theory\/fp\/theory_fp.cpp":"MODIFY"},"diff":{"src\/theory\/fp\/theory_fp.cpp":[{"add":["95","  \/\/ Kinds that are to be handled in the congruence closure","140","","148","  if (Configuration::isAssertionBuild())","149","  {","150","    \/\/ The following kinds should have been removed by the","151","    \/\/ rewriter\/expandDefinition","152","    Kind k = node.getKind();","153","    Assert(k != kind::FLOATINGPOINT_SUB && k != kind::FLOATINGPOINT_MIN","154","           && k != kind::FLOATINGPOINT_MAX && k != kind::FLOATINGPOINT_EQ","155","           && k != kind::FLOATINGPOINT_GEQ && k != kind::FLOATINGPOINT_GT","156","           && k != kind::FLOATINGPOINT_TO_UBV && k != kind::FLOATINGPOINT_TO_SBV","157","           && k != kind::FLOATINGPOINT_TO_REAL)","158","        << \"Expected floating-point kind \" << k << \" to be removed\";","159","  }","160",""],"delete":["94","  \/\/ Kinds that are to be handled in the congruence closure","99","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_SUB); \/\/ Removed","106","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_MIN); \/\/ Removed","107","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_MAX); \/\/ Removed","111","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_EQ); \/\/ Removed","114","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_GEQ); \/\/ Removed","115","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_GT); \/\/ Removed","130","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_TO_UBV); \/\/ Removed","131","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_TO_SBV); \/\/ Removed","132","  \/\/ d_equalityEngine->addFunctionKind(kind::FLOATINGPOINT_TO_REAL); \/\/ Removed"]}]}},"9b7ba1603b2d6ff4c13182655ca8af32966570aa":{"changes":{"test\/regress\/regress1\/rr-verify\/fp-bool.sy":"MODIFY","src\/expr\/node_manager.h":"MODIFY","src\/theory\/quantifiers\/candidate_rewrite_database.cpp":"MODIFY","src\/expr\/expr_template.cpp":"MODIFY","test\/regress\/regress1\/rr-verify\/fp-arith.sy":"MODIFY","test\/regress\/regress1\/rr-verify\/bv-term.sy":"MODIFY","src\/theory\/quantifiers\/expr_miner.cpp":"MODIFY","src\/theory\/quantifiers\/query_generator.cpp":"MODIFY"},"diff":{"test\/regress\/regress1\/rr-verify\/fp-bool.sy":[{"add":[],"delete":["0","; REQUIRES: no-asan"]}],"src\/expr\/node_manager.h":[{"add":["278","","279","    \/\/ `d_zombies` uses the node id to hash and compare nodes. If `d_zombies`","280","    \/\/ already contains a node value with the same id as `nv`, but the pointers","281","    \/\/ are different, then the wrong `NodeManager` was in scope for one of the","282","    \/\/ two nodes when it reached refcount zero. This can happen for example if","283","    \/\/ you create a node with a `NodeManager` n1 and then call `Node::toExpr()`","284","    \/\/ on that node while a different `NodeManager` n2 is in scope. When that","285","    \/\/ `Expr` is deleted and the node reaches refcount zero in the `Expr`'s","286","    \/\/ destructor, then `markForDeletion()` will be called on n2.","287","    Assert(d_zombies.find(nv) == d_zombies.end() || *d_zombies.find(nv) == nv);","288",""],"delete":[]}],"src\/theory\/quantifiers\/candidate_rewrite_database.cpp":[{"add":["141","        ExprManagerMapCollection varMap;"],"delete":["139","        ExprManagerMapCollection varMap;"]}],"src\/expr\/expr_template.cpp":[{"add":["202","","203","            \/\/ Make sure that the correct `NodeManager` is in scope while","204","            \/\/ converting the node to an expression.","205","            NodeManagerScope to_nms(to_nm);","220","","221","            \/\/ Make sure that the correct `NodeManager` is in scope while","222","            \/\/ converting the node to an expression.","223","            NodeManagerScope to_nms(to_nm);","238","","239","            \/\/ Make sure that the correct `NodeManager` is in scope while","240","            \/\/ converting the node to an expression.","241","            NodeManagerScope to_nms(to_nm);","258","","259","        \/\/ Make sure that the expressions are associated with the correct","260","        \/\/ `ExprManager`s.","261","        Assert(from_e.getExprManager() == from);","262","        Assert(to_e.getExprManager() == to);"],"delete":[]}],"test\/regress\/regress1\/rr-verify\/fp-arith.sy":[{"add":[],"delete":["0","; REQUIRES: no-asan"]}],"test\/regress\/regress1\/rr-verify\/bv-term.sy":[{"add":[],"delete":["0","; REQUIRES: no-asan"]}],"src\/theory\/quantifiers\/expr_miner.cpp":[{"add":["135","  ExprManagerMapCollection varMap;"],"delete":["133","  ExprManagerMapCollection varMap;"]}],"src\/theory\/quantifiers\/query_generator.cpp":[{"add":["189","    ExprManagerMapCollection varMap;"],"delete":["187","    ExprManagerMapCollection varMap;"]}]}},"2b7c294a2056b6083457ae5cd86d7481c9cee747":{"changes":{"src\/context\/cdhashmap.h":"MODIFY"},"diff":{"src\/context\/cdhashmap.h":[{"add":["170","    \/\/ don't need to save the key---and if we do we can get","171","    \/\/ refcounts for Node keys messed up and leak memory","172","    d_key(),"],"delete":["170","    d_key(other.d_key),"]}]}},"b7d0c09bd12b9d0f46deab199714ce3441206d7f":{"changes":{"src\/theory\/quantifiers_engine.cpp":"MODIFY","src\/theory\/quantifiers_engine.h":"MODIFY"},"diff":{"src\/theory\/quantifiers_engine.cpp":[{"add":["63","QuantifiersEngine::QuantifiersEngine(context::Context* c,","64","                                     context::UserContext* u, TheoryEngine* te)","65","    : d_te(te),","66","      d_conflict_c(c, false),","67","      \/\/ d_quants(u),","68","      d_quants_red(u),","69","      d_lemmas_produced_c(u),","70","      d_skolemized(u),","71","      d_quant_attr(new quantifiers::QuantAttributes(this)),","72","      d_ierCounter_c(c),","73","      \/\/ d_ierCounter(c),","74","      \/\/ d_ierCounter_lc(c),","75","      \/\/ d_ierCounterLastLc(c),","76","      d_presolve(u, true),","77","      d_presolve_in(u),","78","      d_presolve_cache(u),","79","      d_presolve_cache_wq(u),","80","      d_presolve_cache_wic(u) {"],"delete":["63","QuantifiersEngine::QuantifiersEngine(context::Context* c, context::UserContext* u, TheoryEngine* te):","64","    d_te( te ),","65","    d_conflict_c(c, false),","66","    \/\/d_quants(u),","67","    d_quants_red(u),","68","    d_lemmas_produced_c(u),","69","    d_skolemized(u),","70","    d_ierCounter_c(c),","71","    \/\/d_ierCounter(c),","72","    \/\/d_ierCounter_lc(c),","73","    \/\/d_ierCounterLastLc(c),","74","    d_presolve(u, true),","75","    d_presolve_in(u),","76","    d_presolve_cache(u),","77","    d_presolve_cache_wq(u),","78","    d_presolve_cache_wic(u){","93","  ","94","  d_quant_attr = new quantifiers::QuantAttributes( this );"]}],"src\/theory\/quantifiers_engine.h":[{"add":["21","#include <memory>","203","  std::unique_ptr<quantifiers::QuantAttributes> d_quant_attr;","382","  quantifiers::QuantAttributes* getQuantAttributes() {","383","    return d_quant_attr.get();","384","  }"],"delete":["202","  quantifiers::QuantAttributes* d_quant_attr;","381","  quantifiers::QuantAttributes* getQuantAttributes() { return d_quant_attr; }"]}]}},"8799bd979c40477d250cada8b498ce344ae61ab6":{"changes":{"test\/unit\/expr\/node_algorithm_black.h":"MODIFY"},"diff":{"test\/unit\/expr\/node_algorithm_black.h":[{"add":["46","    delete d_bvTypeNode;","48","    delete d_intTypeNode;","212","","213"," private:","214","  NodeManager* d_nodeManager;","215","  NodeManagerScope* d_scope;","216","  TypeNode* d_intTypeNode;","217","  TypeNode* d_boolTypeNode;","218","  TypeNode* d_bvTypeNode;"],"delete":["34"," private:","35","  NodeManager* d_nodeManager;","36","  NodeManagerScope* d_scope;","37","  TypeNode* d_intTypeNode;","38","  TypeNode* d_boolTypeNode;","39","  TypeNode* d_bvTypeNode;","40","","53","    delete d_intTypeNode;"]}]}},"8b5b4e7c9df5bd9d5959c7c92a5b28c951881d49":{"changes":{"src\/prop\/bvminisat\/bvminisat.h":"MODIFY","src\/prop\/bvminisat\/bvminisat.cpp":"MODIFY"},"diff":{"src\/prop\/bvminisat\/bvminisat.h":[{"add":["20","#include <memory>","21","","53","\tstd::unique_ptr<BVMinisat::SimpSolver> d_minisat;","54","\tstd::unique_ptr<MinisatNotify> d_minisatNotify;"],"delete":["51","  BVMinisat::SimpSolver* d_minisat;","52","  MinisatNotify* d_minisatNotify;"]}],"src\/prop\/bvminisat\/bvminisat.cpp":[{"add":["29","  d_minisatNotify(nullptr),","35","  d_statistics.init(d_minisat.get());","54","  d_minisatNotify.reset(new MinisatNotify(notify));","55","  d_minisat->setNotify(d_minisatNotify.get());"],"delete":["29","  d_minisatNotify(0),","35","  d_statistics.init(d_minisat);","40","  delete d_minisat;","41","  delete d_minisatNotify;","56","  d_minisatNotify = new MinisatNotify(notify);","57","  d_minisat->setNotify(d_minisatNotify);"]}]}},"4a5b3ec8ea8d2826517f975ad66fdfcd06ceab71":{"changes":{"test\/unit\/api\/c\/capi_input_parser_black.cpp":"MODIFY"},"diff":{"test\/unit\/api\/c\/capi_input_parser_black.cpp":[{"add":["241","  cvc5_parser_append_inc_str_input(parser, \"(set-logic ALL)\\n\");","245","  cvc5_parser_append_inc_str_input(parser, \"(declare-fun a () Int)\\n\");","246","  cmd = cvc5_parser_next_command(parser, &error_msg);","247","  ASSERT_NE(cmd, nullptr);","248","  (void)cvc5_cmd_invoke(cmd, d_solver, d_sm);","312","  cvc5_delete(solver4);","313","  cvc5_delete(solver3);","314","  cvc5_delete(solver2);"],"delete":["241","  cvc5_parser_append_inc_str_input(parser, \"(declare-fun a () Int)\\n\");"]}]}},"5852810e110a002ad9a3b04b929470a4b61abe98":{"changes":{"src\/parser\/antlr_input.cpp":"MODIFY"},"diff":{"src\/parser\/antlr_input.cpp":[{"add":["391","std::string parseErrorHelper(const char* lineStart,","392","                             std::size_t lineLength,","393","                             std::size_t charPositionInLine,","394","                             const std::string& message)","410","  std::size_t posSliceStart =","411","      (charPositionInLine <= 50) ? 0 : charPositionInLine - 50 + 5;","412","  std::size_t posSliceEnd = posSliceStart + 70;","413","  std::size_t caretPos = 0;","414","  std::size_t caretPosExtra = 0;  \/\/ for inital intendation, epilipses etc.","421","  for (std::size_t i = posSliceStart; i < lineLength && lineStart[i] != '\\n';","422","       ++i)","423","  {","509","  auto lineLength = d_antlr3InputStream->sizeBuf","510","                    - (static_cast<char*>(d_antlr3InputStream->currentLine)","511","                       - static_cast<char*>(d_antlr3InputStream->data));","512","  std::string updatedMessage = parseErrorHelper(","513","      (const char*)d_antlr3InputStream->getLineBuf(d_antlr3InputStream),","514","      lineLength,","515","      d_lexer->getCharPositionInLine(d_lexer),","516","      message);"],"delete":["391","std::string parseErrorHelper(const char* lineStart, int charPositionInLine, const std::string& message)","407","  int posSliceStart = (charPositionInLine - 50 <= 0) ? 0 : charPositionInLine - 50 + 5;","408","  int posSliceEnd = posSliceStart + 70;","409","  int caretPos = 0;","410","  int caretPosExtra = 0; \/\/ for inital intendation, epilipses etc.","417","  for(int i = posSliceStart; lineStart[i] != '\\n'; ++i) {","503","  string updatedMessage = parseErrorHelper((const char*)d_antlr3InputStream->getLineBuf(d_antlr3InputStream),","504","                                           d_lexer->getCharPositionInLine(d_lexer),","505","                                           message);"]}]}},"fda8400531b63ccc728b1ce22ccf000067707df8":{"changes":{"src\/base\/cvc4_assert.cpp":"MODIFY"},"diff":{"src\/base\/cvc4_assert.cpp":[{"add":["40","  buf = new char[n];","43"," ","68","      buf = new char[n];"],"delete":["42","    buf = new char[n];","43",""]}]}},"ea8937689b097d41c70060ed17495feed5d6b95b":{"changes":{"test\/regress\/CMakeLists.txt":"MODIFY"},"diff":{"test\/regress\/CMakeLists.txt":[{"add":["2389","  # currently slow at c9fd28a","2390","  regress1\/sygus\/issue3580.sy"],"delete":["1859","  regress1\/sygus\/issue3580.sy"]}]}},"08c1ed76932102948bca5157a5da64033ea1c408":{"changes":{"src\/theory\/rewriter.cpp":"MODIFY"},"diff":{"src\/theory\/rewriter.cpp":[{"add":["37","static thread_local std::unique_ptr<std::unordered_set<Node, NodeHashFunction>>","38","    s_rewriteStack = nullptr;","96","  if (s_rewriteStack == nullptr)","97","  {","98","    s_rewriteStack.reset(new std::unordered_set<Node, NodeHashFunction>());","259","  if (s_rewriteStack != nullptr)","260","  {","261","    s_rewriteStack.reset(nullptr);"],"delete":["37","static thread_local std::unordered_set<Node, NodeHashFunction>* s_rewriteStack = NULL;","95","  if(s_rewriteStack == NULL) {","96","    s_rewriteStack = new std::unordered_set<Node, NodeHashFunction>();","257","  if(s_rewriteStack != NULL) {","258","    delete s_rewriteStack;","259","    s_rewriteStack = NULL;"]}]}},"7c10e3b927c4f7b4cf2ae285cc8f9485e2616db6":{"changes":{"proofs\/lfsc_checker\/check.cpp":"MODIFY","proofs\/lfsc_checker\/expr.cpp":"MODIFY"},"diff":{"proofs\/lfsc_checker\/check.cpp":[{"add":["89","Expr *statType = new CExpr(TYPE);","90","Expr *statKind = new CExpr(KIND);","91","Expr *statMpz = new CExpr(MPZ);","92","Expr *statMpq = new CExpr(MPQ);","468","      Expr *tp_of_trm = NULL;"],"delete":["89","Expr *statType = new CExpr(TYPE, 0);","90","Expr *statKind = new CExpr(KIND, 0);","91","Expr *statMpz = new CExpr(MPZ,0);","92","Expr *statMpq = new CExpr(MPQ,0);","468","      Expr *tp_of_trm;"]}],"proofs\/lfsc_checker\/expr.cpp":[{"add":["207","    Expr **kids = new Expr *[args.size() - start + 2];","208","    kids[0] = hd;","210","      kids[i - start + 1] = args[i];","211","    kids[args.size() - start + 1] = NULL;","212","    return new CExpr(APP, true \/* dummy *\/, kids);","230","      Expr **kids = new Expr *[counter + 2];","233","        kids[counter] = ((CExpr *)e1)->kids[counter];","234","        kids[counter]->inc();","235","        counter++;","237","      kids[counter] = e2;","238","      kids[counter + 1] = NULL;","239","      ret = new CExpr(APP, true \/* dummy *\/, kids);","370","    Expr **kids = new Expr *[args.size() + 2];","371","    kids[0] = hd;","372","    for (size_t a = 0; a < args.size(); a++) {","373","      kids[a + 1] = convert_to_flat_app(args[a]);","375","    kids[args.size() + 1] = 0;","376","    CExpr *nce = new CExpr(APP, true \/* dummy *\/, kids);","647","        if (tmp->free_in(x)) return true;"],"delete":["207","    CExpr *ret = new CExpr( APP );","208","    ret->kids = new Expr* [args.size()-start+2];","209","    ret->kids[0] = hd;","211","        ret->kids[i-start+1] = args[i];","212","    ret->kids[args.size()-start+1] = NULL;","213","    return ret;","231","      ret = new CExpr( APP );","232","      ret->kids = new Expr* [counter+2];","235","         ret->kids[counter] = ((CExpr*)e1)->kids[counter];","236","         ret->kids[counter]->inc();","237","         counter++;","239","      ret->kids[counter] = e2;","240","      ret->kids[counter+1] = NULL;","371","    CExpr* nce = new CExpr( APP );","372","    nce->kids = new Expr *[(int)args.size()+2];","373","    nce->kids[0] = hd;","374","    for( int a=0; a<(int)args.size(); a++ )","375","    {","376","      nce->kids[a+1] = convert_to_flat_app( args[a] );","378","    nce->kids[(int)args.size()+1] = 0;","649","         if (tmp->free_in(x))","650","\t         return true;"]}]}},"0a5763ef49f7981a7a990a08bc0ce4f0a8ff36b1":{"changes":{"src\/options\/managed_streams.cpp":"MODIFY","src\/options\/managed_streams.h":"MODIFY"},"diff":{"src\/options\/managed_streams.cpp":[{"add":["74","std::unique_ptr<std::ostream> openOStream(const std::string& filename)","77","  std::unique_ptr<std::ostream> res = std::make_unique<std::ofstream>(filename);","78","  if (!res || !*res)","86","std::unique_ptr<std::istream> openIStream(const std::string& filename)","89","  std::unique_ptr<std::istream> res = std::make_unique<std::ifstream>(filename);","90","  if (!res || !*res)"],"delete":["74","std::ostream* openOStream(const std::string& filename)","77","  std::ostream* res;","78","  res = new std::ofstream(filename);","79","  if (res == nullptr || !*res)","87","std::istream* openIStream(const std::string& filename)","90","  std::istream* res;","91","  res = new std::ifstream(filename);","92","  if (res == nullptr || !*res)"]}],"src\/options\/managed_streams.h":[{"add":["33","std::unique_ptr<std::ostream> openOStream(const std::string& filename);","38","std::unique_ptr<std::istream> openIStream(const std::string& filename);","66","      d_owned = detail::openOStream(value);","72","      d_owned = detail::openIStream(value);"],"delete":["33","std::ostream* openOStream(const std::string& filename);","38","std::istream* openIStream(const std::string& filename);","66","      d_owned.reset(detail::openOStream(value));","72","      d_owned.reset(detail::openIStream(value));"]}]}},"341728ed95dcff20fd75bb7aef4e0b7773f63e07":{"changes":{"src\/theory\/quantifiers\/sygus_grammar_norm.h":"MODIFY","src\/theory\/quantifiers\/sygus_grammar_norm.cpp":"MODIFY"},"diff":{"src\/theory\/quantifiers\/sygus_grammar_norm.h":[{"add":["19","#include <map>","20","#include <memory>","21","#include <string>","22","#include <vector>","23","","24","#include \"expr\/datatype.h\"","25","#include \"expr\/node.h\"","27","#include \"expr\/type.h\"","28","#include \"expr\/type_node.h\"","89","                     const std::vector<unsigned>& op_pos,","252","    virtual ~Transf() {}","253","","275","    TransfDrop(const std::vector<unsigned>& indices) : d_drop_indices(indices)","276","    {","277","    }","279","    void buildType(SygusGrammarNorm* sygus_norm,","280","                   TypeObject& to,","281","                   const Datatype& dt,","282","                   std::vector<unsigned>& op_pos) override;","309","    TransfChain(unsigned chain_op_pos, const std::vector<unsigned>& elem_pos)","337","    void buildType(SygusGrammarNorm* sygus_norm,","338","                   TypeObject& to,","339","                   const Datatype& dt,","340","                   std::vector<unsigned>& op_pos) override;","445","  std::unique_ptr<Transf> inferTransf(TypeNode tn,","446","                                      const Datatype& dt,","447","                                      const std::vector<unsigned>& op_pos);"],"delete":["80","                     std::vector<unsigned> op_pos,","264","    TransfDrop(std::vector<unsigned>& indices) : d_drop_indices(indices) {}","266","    virtual void buildType(SygusGrammarNorm* sygus_norm,","267","                           TypeObject& to,","268","                           const Datatype& dt,","269","                           std::vector<unsigned>& op_pos);","296","    TransfChain(unsigned chain_op_pos, std::vector<unsigned>& elem_pos)","324","    virtual void buildType(SygusGrammarNorm* sygus_norm,","325","                           TypeObject& to,","326","                           const Datatype& dt,","327","                           std::vector<unsigned>& op_pos) override;","432","  Transf* inferTransf(TypeNode tn,","433","                      const Datatype& dt,","434","                      const std::vector<unsigned>& op_pos);"]}],"src\/theory\/quantifiers\/sygus_grammar_norm.cpp":[{"add":["37","                              const std::vector<unsigned>& op_pos,","276","std::unique_ptr<SygusGrammarNorm::Transf> SygusGrammarNorm::inferTransf(","297","      return std::unique_ptr<Transf>(new TransfDrop(rindices));","365","    return std::unique_ptr<Transf>(new TransfChain(chain_op_pos, elem_pos));","419","  std::unique_ptr<Transf> transformation = inferTransf(tn, dt, op_pos);"],"delete":["37","                              std::vector<unsigned> op_pos,","276","SygusGrammarNorm::Transf* SygusGrammarNorm::inferTransf(","297","      return new TransfDrop(rindices);","365","    return new TransfChain(chain_op_pos, elem_pos);","419","  Transf* transformation = inferTransf(tn, dt, op_pos);"]}]}},"c2c26a121f022c48938196d68b615816ac0b1489":{"changes":{"src\/theory\/quantifiers\/term_database.cpp":"MODIFY","src\/theory\/inference_id.cpp":"MODIFY","src\/theory\/uf\/theory_uf.h":"MODIFY","src\/CMakeLists.txt":"MODIFY","test\/regress\/cli\/CMakeLists.txt":"MODIFY","test\/regress\/cli\/regress1\/issue8958-bv2nat-lazy.smt2":"ADD","src\/theory\/uf\/theory_uf.cpp":"MODIFY","src\/theory\/inference_id.h":"MODIFY","src\/theory\/uf\/conversions_solver.cpp":"ADD","src\/options\/uf_options.toml":"MODIFY","src\/theory\/uf\/conversions_solver.h":"ADD"},"diff":{"src\/theory\/quantifiers\/term_database.cpp":[{"add":["193","      || k == SEP_PTO || k == HO_APPLY || k == SEQ_NTH || k == STRING_LENGTH","194","      || k == BITVECTOR_TO_NAT || k == INT_TO_BITVECTOR)"],"delete":["193","      || k == SEP_PTO || k == HO_APPLY || k == SEQ_NTH || k == STRING_LENGTH)"]}],"src\/theory\/inference_id.cpp":[{"add":["523","    case InferenceId::UF_ARITH_BV_CONV_REDUCTION:","524","      return \"UF_ARITH_BV_CONV_REDUCTION\";"],"delete":[]}],"src\/theory\/uf\/theory_uf.h":[{"add":["35","class ConversionsSolver;","80","  \/** the conversions solver *\/","81","  std::unique_ptr<ConversionsSolver> d_csolver;"],"delete":[]}],"src\/CMakeLists.txt":[{"add":["1174","  theory\/uf\/conversions_solver.cpp","1175","  theory\/uf\/conversions_solver.h"],"delete":[]}],"test\/regress\/cli\/CMakeLists.txt":[{"add":["278","  regress0\/bv\/bv2nat-ground-c.smt2","2041","  regress1\/issue8958-bv2nat-lazy.smt2"],"delete":["3223","  # temporarily disabled, solved quickly with lazy conversion","3224","  regress0\/bv\/bv2nat-ground-c.smt2"]}],"test\/regress\/cli\/regress1\/issue8958-bv2nat-lazy.smt2":[{"add":[],"delete":[]}],"src\/theory\/uf\/theory_uf.cpp":[{"add":["32","#include \"theory\/uf\/conversions_solver.h\"","117","  \/\/ last call effort needed if using finite model finding or","118","  \/\/ arithmetic\/bit-vector conversions","119","  return d_thss != nullptr || d_csolver != nullptr;","135","    \/\/ check with conversions solver at last call effort","136","    if (d_csolver != nullptr && level == Effort::EFFORT_LAST_CALL)","137","    {","138","      d_csolver->check();","139","    }","238","  else if ((k == kind::BITVECTOR_TO_NAT || k == kind::INT_TO_BITVECTOR)","239","           && options().uf.eagerArithBvConv)","241","    \/\/ eliminate if option specifies to eliminate eagerly","299","      Assert(!options().uf.eagerArithBvConv);","300","      d_equalityEngine->addTerm(node);","301","      d_functionsTerms.push_back(node);","302","      \/\/ initialize the conversions solver if not already done so","303","      if (d_csolver == nullptr)","304","      {","305","        d_csolver.reset(new ConversionsSolver(d_env, d_state, d_im));","306","      }","307","      \/\/ call preregister","308","      d_csolver->preRegisterTerm(node);"],"delete":["116","  \/\/ last call effort needed if using finite model finding","117","  return d_thss != nullptr;","231","  else if (k == kind::BITVECTOR_TO_NAT || k == kind::INT_TO_BITVECTOR)","233","    \/\/ temporary, always eliminate eagerly","291","      \/\/ temporary, will add conversions solver support here","292","      Unhandled() << \"TheoryUF::preRegisterTerm: registered a conversion term \"","293","                  << node << std::endl;"]}],"src\/theory\/inference_id.h":[{"add":["927","  \/\/-------------------- UF arith\/bv conversions solver","928","  \/\/ reductions of an arithmetic\/bit-vector conversion term","929","  UF_ARITH_BV_CONV_REDUCTION,"],"delete":[]}],"src\/theory\/uf\/conversions_solver.cpp":[{"add":[],"delete":[]}],"src\/options\/uf_options.toml":[{"add":["68","","69","[[option]]","70","  name       = \"eagerArithBvConv\"","71","  category   = \"expert\"","72","  long       = \"eager-arith-bv-conv\"","73","  type       = \"bool\"","74","  default    = \"false\"","75","  help       = \"eagerly expand bit-vector to arithmetic conversions during preprocessing\""],"delete":[]}],"src\/theory\/uf\/conversions_solver.h":[{"add":[],"delete":[]}]}}}